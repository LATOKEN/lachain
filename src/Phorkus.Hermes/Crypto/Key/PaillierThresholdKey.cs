using System.IO;
using Org.BouncyCastle.Math;

namespace Phorkus.Hermes.Crypto.Key
{
/**
 * A public key for the threshold Paillier cryptosystem
 * <i>CS</i><sub>1</sub>. 
 * Provides encryption credentials to encrypt, as well as the public
 * variables and values needed for the threshold variant of the Paillier
 * Public Key System.  This threshold key includes the public key needed
 * to encrypt a message (i.e. the <i>n</i> and <i>g</i> needed) and the
 * public values needed to Verify messages in the threshold scheme (i.e.
 * the verifier <i>v</i> and the public verifier <i>v<sub>i</sub></i>
 * for each decryption server).
 * <p>
 * The public key for the threshold variant is nothing more than the
 * <i>n</i> and <i>g</i> as provided for in {@link PaillierKey} and the
 * following additional public variables:
 * <ul>
 *   <li><i>l</i> is the total number of decryption servers
 *   <li><i>w</i> is the threshold minimum number of decryption servers needed to 
 *       decrypt a message; <i>w</i> must be less than or equal to half of
 *       <i>l</i>
 *   <li><i>v</i> is a number used to Verify actions of the decryption servers.
 *       This value <i>v</i> generates the cyclic group of squares in
 *       <i>Z</i><sup>*</sup><sub><i>n</i><sup><i>s+1</i></sup></sub>
 *   <li><i>v<sub>i</sub></i> is a verification key unique to each decryption
 *       server <i>i</i>.  The key <i>v<sub>i</sub></i> should be equal to
 *       <i>v</i><sup>&Delta;<i>s<sub>i</sub></i></sup> where &Delta;=<i>l</i>!
 *       (i.e. &Delta; is the factorial of the number of decryption servers).
 *   <li>&Theta;' is a public value used in the context of a decentralized key 
 *   	 generation. When outside this context, it is simply 1.</li>
 * </ul>
 * <p>
 * The set of verification keys {<i>v<sub>i</sub></i>} is generated by the key
 * generator and passed as an argument to this class, as well as all the above
 * mentioned variables.
 * <p>
 * The public information contained in this key is sufficient to completely
 * decrypt a ciphertext <i>c</i>, <i>given the k&ge;w partial decryptions
 * c<sub>1</sub>,...,c<sub>k</sub></i>.
 * <p> This class provides one unique implementation of the public key in both
 * the centralized and distributed generation approach. A specific constructor
 * can be used in the case where no trusted dealer is present and the key where
 * generated using the method described by T. Nishide and K. Sakurai in 
 * <i>Distributed Paillier Cryptosystem without Trusted Dealer</i>.
 * <p>
 * <b>NOTE:</b> This is for the implementation where <i>s</i>=1.
 * 
 * @author James Garrity
 * @author Sean Hall
 * @see paillierp.PaillierThreshold
 */
    public class PaillierThresholdKey : PaillierKey
    {
        /*
         * 
         * Fields
         * 
         */

        /**
         * This Serial ID
         */
        private static long serialVersionUID = -7453847065116591940L;

        /** 
         * Generates a cyclic group of squares in
         * <i>Z</i><sup>*</sup><sub><i>n</i><sup>2</sup></sub>.
         */
        protected BigInteger v = null;

        /**
         * Verification key for each of the <code>l</code> decryption servers.
         * In essence,
         * <i>v<sub>i</sub></i>=<i>v</i><sup><i>&Delta;s<sub>i</sub></i></sup>.
         */
        protected BigInteger[] vi = null;

        /** Number of decryption servers <i>L</i>. */
        protected int l;
        //l is only needed to compute delta

        /** &Delta;=<i>L</i>!; this is used often in decryption algorithms. */
        protected BigInteger delta;

        /**
         * The minimum of decryption servers needed to make a correct decryption.
         */
        protected int w;
        // I don't think w is needed anywhere except for the key generation

        /**
         * &Theta;' = &Delta; &Phi;(<i>N</i>) &Beta; + <i>N</i> &Delta; <i>R</i> is used
         * in the context of Threshold Paillier without trusted dealer, where the private
         * keys are of the form &Theta;' - <i>N f</i>(<i>x</i>). If it is not the case, 
         * it should be equal to 1.
         */
        protected BigInteger thetaPrime;

        /**
         * The cached value of (4&Delta;<sup>2</sup>)<sup>-1</sup> mod
         * <i>n<sup>s</sup></i>
         */
        private BigInteger combineSharesConstant;

        //TODO add the value s in the public key (if s is anything else but 1)

        /*
         * 
         * Constructors
         * 
         */

        /**
         * Creates a new public key for the generalized Paillier threshold scheme
         * from the given modulus <code>n</code>, for use on <code>l</code>
         * decryption servers, <code>w</code> of which are needed to decrypt
         * any message encrypted by using this public key.  The values
         * <code>v</code> and <code>vi</code> correspond to the public
         * values <i>v</i> and
         * <i>v<sub>i</sub></i>=<i>v</i><sup><i>l</i>!<i>s<sub>i</sub></i></sup>
         * needed to Verify the zero knowledge proofs.
         * 
         * @param n         a safe prime product of <i>p</i> and <i>q</i> where
         *                  <i>p'</i>=(<i>p</i>-1)/2 and <i>a'</i>=(<i>a</i>-1)/2
         *                  are also both primes
         * @param l         number of decryption servers
         * @param w         threshold of servers needed to successfully decrypt any
         *                  ciphertext created by this public key.
         * @param v         a generator of a cyclic group of squares in
         *                  <i>Z</i><sup>*</sup><sub><code>n</code><sup>2</sup></sub>
         * @param viarray   array of verification keys where <code>vi[i]</code> is
         *                  <code>v</code><sup><code>l</code>!<i>s</i><sub><code>i</code></sub></sup>
         *                  where <i>s</i><sub><code>i</code></sub> is the private key
         *                  for decryption server <code>i</code>
         * @param seed      a long integer needed to start a random number generator
         */
        public PaillierThresholdKey(BigInteger n, int l, int w, BigInteger v, BigInteger[] viarray, int seed)
            : base(n, seed)
        {
            this.l = l;
            this.delta = KeyGen.factorial(l);
            this.thetaPrime = BigInteger.One;
            this.combineSharesConstant = BigInteger.ValueOf(4).Multiply(delta.Multiply(delta).Multiply(thetaPrime))
                .ModInverse(ns);
            this.w = w;
            this.v = v;
            this.vi = viarray;
        }

        /**
         * Creates a new public key for the generalized Paillier threshold scheme
         * from the given modulus <code>n</code>, for use on <code>l</code>
         * decryption servers, <code>w</code> of which are needed to decrypt
         * any message encrypted by using this public key.  The values
         * <code>v</code> and <code>vi</code> correspond to the public
         * values <i>v</i> and
         * <i>v<sub>i</sub></i>=<i>v</i><sup><i>l</i>!<i>s<sub>i</sub></i></sup>
         * needed to Verify the zero knowledge proofs.
         * 
         * @param n          a safe prime product of <i>p</i> and <i>q</i> where
         *                   <i>p'</i>=(<i>p</i>-1)/2 and <i>a'</i>=(<i>a</i>-1)/2
         *                   are also both primes
         * @param l          number of decryption servers
         * @param combineSharesConstant
         *                   precomputed value (4<code>*l</code>!)<sup>-1</sup>
         *                   mod <code>n</code><sup><i>s</i></sup>
         * @param w          threshold of servers needed to successfully decrypt any
         *                   ciphertext created by this public key.  Note that
         *                   <code>w</code>&le;<code>l</code>/2.
         * @param v          a generator of a cyclic group of squares in
         *                   <i>Z</i><sup>*</sup><sub><code>n</code><sup>2</sup></sub>
         * @param viarray    array of verification keys where <code>vi[i]</code> is
         *                   <code>v</code><sup><code>l</code>!<i>s</i><sub><code>i</code></sub></sup>
         *                   where <i>s</i><sub><code>i</code></sub> is the private
         *                   key for decryption server <code>i</code>
         * @param seed	a long integer needed to start a random number generator
         */
        public PaillierThresholdKey(BigInteger n, int l,
            BigInteger combineSharesConstant, int w, BigInteger v,
            BigInteger[] viarray, int seed)
            : base(n, seed)
        {
            this.l = l;
            this.delta = KeyGen.factorial(l);
            this.combineSharesConstant = combineSharesConstant;
            this.w = w;
            this.v = v;
            this.vi = viarray;
            this.thetaPrime = combineSharesConstant.ModInverse(ns)
                .Divide(delta.Multiply(delta).Multiply(BigInteger.ValueOf(4)));
        }

        /**
         * Creates a new public key for the generalized Paillier threshold scheme
         * from the given modulus <code>n</code>, for use on <code>l</code>
         * decryption servers, <code>w</code> of which are needed to decrypt
         * any message encrypted by using this public key.  The values
         * <code>v</code> and <code>vi</code> correspond to the public
         * values <i>v</i> and
         * <i>v<sub>i</sub></i>=<i>v</i><sup><i>l</i>!<i>s<sub>i</sub></i></sup>
         * needed to Verify the zero knowledge proofs.
         * <p> This constructor is meant to be used in the case of a decentralized 
         * key generation, as described by T. Nishide and K. Sakurai in 
         * <i>Distributed Paillier Cryptosystem without Trusted Dealer</i>. In this case, a
         * new public value &Theta;' needs to be part of the public key.
         * 
         * @param n          a safe prime product of <i>p</i> and <i>q</i> where
         *                   <i>p'</i>=(<i>p</i>-1)/2 and <i>a'</i>=(<i>a</i>-1)/2
         *                   are also both primes
         * @param thetaprime &Theta;' = &Delta; &Phi;(<i>N</i>) &Beta; + <i>N</i> &Delta; <i>R</i>
         * 					 in the context of Threshold Paillier without trusted dealer, where the private
         *					 keys are of the form &Theta;' - <i>N f</i>(<i>x</i>). Other constructors assume
         *					 that it is not the case and set &Theta;' = 1
         * @param l          number of decryption servers
         * @param combineSharesConstant
         *                   precomputed value (4<code>*l</code>!)<sup>-1</sup>
         *                   mod <code>n</code><sup><i>s</i></sup>
         * @param w          threshold of servers needed to successfully decrypt any
         *                   ciphertext created by this public key.  Note that
         *                   <code>w</code>&le;<code>l</code>/2.
         * @param v          a generator of a cyclic group of squares in
         *                   <i>Z</i><sup>*</sup><sub><code>n</code><sup>2</sup></sub>
         * @param viarray    array of verification keys where <code>vi[i]</code> is
         *                   <code>v</code><sup><code>l</code>!<i>s</i><sub><code>i</code></sub></sup>
         *                   where <i>s</i><sub><code>i</code></sub> is the private
         *                   key for decryption server <code>i</code>
         * @param seed	a long integer needed to start a random number generator
         */
        public PaillierThresholdKey(BigInteger n,
            BigInteger thetaprime,
            int l,
            int w,
            BigInteger v,
            BigInteger[] viarray,
            int seed)
            : base(n, seed)
        {
            this.l = l;
            this.thetaPrime = thetaprime;
            this.delta = KeyGen.factorial(l);
            this.combineSharesConstant = BigInteger.ValueOf(4).Multiply(delta.Multiply(delta)).Multiply(thetaprime)
                .ModInverse(ns);
            this.w = w;
            this.v = v;
            this.vi = viarray;
        }

        public PaillierThresholdKey(byte[] b, int seed, bool old)
            : base(ByteUtils.getLowerLayer(b), seed, old)
        {
            int offset = ByteUtils.getInt(b, b.Length - 4);

            this.l = ByteUtils.getInt(b, offset);
            this.delta = KeyGen.factorial(l);
            this.combineSharesConstant = BigInteger.ValueOf(4).Multiply(delta.Multiply(delta)).ModInverse(ns);
            offset += 4;

            this.w = ByteUtils.getInt(b, offset);
            offset += 4;

            int length = ByteUtils.getInt(b, offset);
            offset += 4;

            this.v = ByteUtils.getBigInt(b, offset, length);
            offset += length;

            this.vi = new BigInteger[l];
            for (int i = 0; i < vi.Length; i++)
            {
                length = ByteUtils.getInt(b, offset);
                this.vi[i] = ByteUtils.getBigInt(b, offset + 4, length);
                offset += length + 4;
            }
        }

        /**
         * Creates a new public threshold key using a byte encoding of a key.
         * 
         * @param b			Byte array of the necessary values of this private key
         * @param seed		a long integer needed to start a random number generator
         * @throws IOException if the key could not be read from the byte array
         * 
         * @see #toByteArray()
         */
        public PaillierThresholdKey(byte[] b, int seed)
            : base(b, seed)
        {
            // The encoding is:
            // [ prev. layer ]
            // [ l ] 4 bytes
            // [ w ] 4 bytes
            // [ bytelenght of thetaprime] 4 bytes
            // [ bytelength of v ] 4 bytes
            // [ bytelength of v1 ] 4 bytes
            // [ ... ]
            // [ bytelength of vl ] 4 bytes
            // [ thetaprime ]
            // [ v ]
            // [ v1 ]
            // ...
            // [ vl ]

            using (var stream = new MemoryStream(b, base.byteArraySize(), b.Length - base.byteArraySize(), false))
            using (var reader = new BinaryReader(stream))
            {
                this.l = reader.ReadInt32();
                this.w = reader.ReadInt32();
                int byteLenThetaprime = reader.ReadInt32();
                int byteLenV = reader.ReadInt32();
                int[] byteLenVi = new int[l];
                for (int i = 0; i < l; i++)
                {
                    byteLenVi[i] = reader.ReadInt32();
                }

                this.vi = new BigInteger[l];

                byte[] temp = reader.ReadBytes(byteLenThetaprime);
                ;
                this.thetaPrime = new BigInteger(temp);
                temp = reader.ReadBytes(byteLenV);
                this.v = new BigInteger(temp);
                for (int i = 0; i < l; i++)
                {
                    temp = reader.ReadBytes(byteLenVi[i]);
                    this.vi[i] = new BigInteger(temp);
                }

                this.delta = KeyGen.factorial(l);
                this.combineSharesConstant = BigInteger.ValueOf(4).Multiply(delta.Multiply(delta)).Multiply(thetaPrime)
                    .ModInverse(ns);
            }
        }

        /*
         * 
         * Methods
         * 
         */

        /**
         * The public key that may be used to encrypt data for private
         * Paillier keys.  This includes the public values of <i>v</i> and
         * {<i>v<sub>i</sub></i>} and <i>l</i> and <i>w</i>
         * 
         * @return The Paillier public key corresponding to this key with
         *         with the public verification values.
         */
        public PaillierThresholdKey getThresholdKey()
        {
            return new PaillierThresholdKey(n, l, combineSharesConstant, w,
                v, vi, (int) rnd.NextDouble());
        }


        /** Return &Theta;', the second public value when keys are generated in a decentralized
         * way.
         * @return &Theta;' = &Delta; &Phi;(<i>N</i>) &Beta; + <i>N</i> &Delta; <i>R</i> 
         *  if the keys are of the form &Theta;' - <i>N f</i>(<i>x</i>), <br>
         *  1 otherwise
         */
        public BigInteger getThetaPrime()
        {
            return thetaPrime;
        }

        /**
         * Returns the public verification value.
         * @return		verification value which generates the cyclic group
         * 				of squares in <i>Z</i><sup>*</sup><sub><i>n</i><sup>2</sup></sub>
         */
        public BigInteger getV()
        {
            return v;
        }

        /**
         * Returns the verification keys for each decryption server.
         * Used for verification proofs.
         * 
         * @return		verification keys for each of the l decryption servers
         */
        public BigInteger[] getVi()
        {
            return vi;
        }

        /**
         * Returns the number of decryption servers.
         * @return		the number of decryption servers
         */
        public int getL()
        {
            return l;
        }

        /**
         * Returns the cached value &Delta;=<i>l</i>! where <i>l</i> is the
         * number of decryption servers.  This is frequently used for
         * decryption.
         * 
         * @return		the value <code>l</code>!
         */
        public BigInteger getDelta()
        {
            return delta;
        }

        /**
         * Returns the threshold number of decryption servers needed to
         * successfully decrypt any ciphertext created by this key.
         * 
         * @return		the minimum number of decryption servers needed
         * 				to make a correct decryption
         */
        public int getW()
        {
            return w;
        }

        /**
         * Returns a cached value of (4*&Delta;)<sup>-1</sup> mod <i>n</i>.
         * This value is heavily used for decryption.
         * 
         * @return		the inverse of (4&Delta;) in <i>Z<sub>n</sub></i>
         */
        public BigInteger getCombineSharesConstant()
        {
            return this.combineSharesConstant;
        }

        /**
         * Encodes this key into a byte array.  As this is a public threshold key,
         * the public modulo {@code n}, {@code l}, {@code w}, {@code v}, and
         * {@code vi} will be encoded in that order.
         * Further, before each BigInteger (except {@code n}) is the 4-byte
         * equivalent to the size of the BigInteger for later parsing.
         * 
         * @return			a byte array containing the most necessary values
         * 					of this key.  A byte array of size 0 is returned
         * 					if the key would be too large.
         * 
         * @see #PaillierThresholdKey(byte[], long)
         * @see BigInteger#toByteArray()
         */
        public byte[] toByteArray()
        {
            // The encoding is:
            // [ prev. layer ]
            // [ l ] 4 bytes
            // [ w ] 4 bytes
            // [ bytelenght of thetaprime] 4 bytes
            // [ bytelength of v ] 4 bytes
            // [ bytelength of v1 ] 4 bytes
            // [ ... ]
            // [ bytelength of vl ] 4 bytes
            // [ thetaprime ]
            // [ v ]
            // [ v1 ]
            // ...
            // [ vl ]

            var upperLayer = base.toByteArray();

            using (var stream = new MemoryStream())
            using (var writer = new BinaryWriter(stream))
            {
                writer.Write(upperLayer);
                writer.Write(l);
                writer.Write(w);
                if (thetaPrime is null)
                    thetaPrime = BigInteger.One;
                writer.Write(thetaPrime.ToByteArray().Length);
                writer.Write(v.ToByteArray().Length);
                for (var i = 0; i < l; i++)
                    writer.Write(vi[i].ToByteArray().Length);
                writer.Write(thetaPrime.ToByteArray(), 0, thetaPrime.ToByteArray().Length);
                writer.Write(v.ToByteArray(), 0, v.ToByteArray().Length);
                for (var i = 0; i < l; i++)
                    writer.Write(vi[i].ToByteArray(), 0, vi[i].ToByteArray().Length);
                writer.Flush();
                return stream.ToArray();
            }
        }

        protected int byteArraySize()
        {
            int bigIntArrayByteLength = base.byteArraySize()
                                        + thetaPrime.ToByteArray().Length
                                        + v.ToByteArray().Length;
            for (int i = 0; i < l; i++)
            {
                bigIntArrayByteLength += vi[i].ToByteArray().Length;
            }

            return 4 + 4 + 4 + 4 + l * 4 + bigIntArrayByteLength;
        }
    }
}