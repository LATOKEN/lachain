syntax = "proto3";
option csharp_namespace = "Phorkus.Proto";

/*
    Private Key Generation Flow:
    1. Generating protocol params using generator
    2. BGW
    2.1 Generating private and public params
    2.2 Generating and broadcasting public params for each participant
    2.3 Collecting public params from other participants
    2.4 Calculating Nj from public params and broadcasting it to other participants
    2.5 Collecting Nj from other participants
    2.6 Calculating N from Nj collected
    3. Biprimality test
    3.1 Generate Qj for every N
    3.2 Collect Qj from other participants
    3.3 Validate multiply of these Qj's
    4. Keys Derivation
    4.1 Collect biprimality tests from other participants
    4.2 Generate keys derivation public params and broadcast to other participants
    4.3 Collect keys derivation public params from other participants
    4.4 Calculate THETAj based on just received public params.
    4.5 Broadcast THETAj to other participants.
    4.6 Collect THETAj from other participants
    4.7 Calculate verification key from received THETA's and broadcast to other participants
    4.8 Collect verification keys from other participants
    4.9 Calculate paillier private threshold key (PROFIT)
    
    Signature Flow:
    
*/

//enum GeneratorState {
//    STATE_INITIALIZATION = 0;
//    STATE_GENERATING_SHARE = 1;
//    STATE_COLLECTING_SHARE = 2;
//    STATE_GENERATING_POINT = 3;
//    STATE_COLLECTING_POINT = 4;
//    STATE_GENERATING_PROOF = 5; // <---+
//    STATE_COLLECTING_PROOF = 6; //     | (repeat several times)
//    STATE_VALIDATING_PROOF = 7; // ----+
//    STATE_GENERATING_DERIVATION = 8;
//    STATE_COLLECTING_DERIVATION = 9;
//    STATE_GENERATING_THETA = 10;
//    STATE_COLLECTING_THETA = 11;
//    STATE_GENERATING_VERIFICATION = 12;
//    STATE_COLLECTING_VERIFICATION = 13;
//    STATE_FINALIZATION = 99;
//}

//message BgwPrivateParams {
//    int32 i = 1; // the id of the party
//    int32 n = 2; // the number of parties
//    bytes pi = 3; // the contribution of party Pi to p
//    bytes qi = 4; // the contribution of party Pi to q
//    bytes fi = 5; // the polynomial used to share pi
//    bytes gi = 6; // the polynomial used to share qi
//    bytes hi = 7; // the polynomial used to share Ni
//}

//message CandidateN {
//    bytes n = 1; //  the candidate to RSA modulus   
//    BgwPrivateParams bgw_private_params = 2; // the BGW private parameters associated with the candidate to RSA modulus
//}
//
//message BiprimalityTestResult {
//    bytes n = 1; // the candidate to RSA modulus		
//    BgwPrivateParams bgw_private_params = 2; // the BGW private parameters associated with N    
//    bool passes = 3; // the result of the Biprimality test. True if succeed, false if not
//}

//message KeysDerivationPrivateParams {
//    int32 i = 1; // the id of the party
//    message Polynomial {
//        repeated bytes a = 1;
//    }
//    Polynomial dri_sharing = 2;
//    message PolynomialMod {
//        repeated bytes a = 1;
//        bytes mod = 2;
//    }
//    PolynomialMod betai_sharing = 3;
//    PolynomialMod phi_sharing = 4;
//    PolynomialMod zero_sharing = 5;
//}

// -------------------------------------------------------------------------------------------------------

//message BgwPublicParams {
//    int32 i = 1; // the id of the party
//    int32 n = 2; // the number of parties
//    int32 j = 3; // the id of the party for which these shares were generated
//    bytes pij = 4; // the share pij = f(j) of party i's pi generated for party j
//    bytes qij = 5; // the share qij = g(j) of party i's qi generated for party j
//    bytes hij = 6; // the share hij = h(j) of party i's zero generated for party j
//}
//
//message Complaint {
//    uint32 id = 1; // the id of the party that produced the invalid share
//}
//message BgwnPoint {
//    bytes point = 1; // a share of N
//}
//message ThetaPoint {
//    bytes thetai = 1; // a share of Theta
//}
//message VerificationKey {
//    bytes verification_key = 1; // a verification key
//}
//message QiTestForRound {
//    bytes qi = 1; // a Qi in the Biprimality test
//    uint32 round = 2; // the current round number in the Biprimality test
//}
//
//message GeneratorMessage {
//    oneof message {
//        Complaint complaint = 1;
//        BgwnPoint bgwn_point = 2;
//        ThetaPoint theta_point = 3;
//        VerificationKey verification_key = 4;
//        QiTestForRound qi_test_for_round = 5;
//    }
//}
//
//message KeysDerivationPublicParams {
//    int32 i = 1; // the id of the party
//    int32 j = 2; // the id of the party for which these shares were generated
//    bytes betaij = 3;
//    bytes drij = 4;
//    bytes phiij = 5;
//    bytes hij = 6;
//}