syntax = "proto3";
option csharp_namespace = "Phorkus.Proto";

message BgwPrivateParams {
    uint32 i = 1; // the id of the party
    uint32 n = 2; // the number of parties
    bytes pi = 3; // the contribution of party Pi to p
    bytes qi = 4; // the contribution of party Pi to q
    bytes fi = 5; // the polynomial used to share pi
    bytes gi = 6; // the polynomial used to share qi
    bytes hi = 7; // the polynomial used to share Ni
}

message BgwPublicParams {
    uint32 i = 1; // the id of the party
    uint32 n = 2; // the number of parties
    uint32 j = 3; // the id of the party for which these shares were generated
    bytes pij = 4; // the share pij = f(j) of party i's pi generated for party j
    bytes qij = 5; // the share qij = g(j) of party i's qi generated for party j
    bytes hij = 6; // the share hij = h(j) of party i's zero generated for party j
}

message Complaint {
    uint32 id = 1; // the id of the party that produced the invalid share
}

message BgwnPoint {
    bytes point = 1; // a share of N
}

message ThetaPoint {
    bytes thetai = 1; // a share of Theta
}

message VerificationKey {
    bytes verification_key = 1; // A verification key
}

message QiTestForRound {
    bytes qi = 1; // a Qi in the Biprimality test
    uint32 round = 2; // the current round number in the Biprimality test
}

message CandidateN {
    bytes n = 1; //  the candidate to RSA modulus   
    BgwPrivateParams bgw_private_params = 2; // the BGW private parameters associated with the candidate to RSA modulus
}

message BiprimalityTestResult {
    bytes n = 1; // the candidate to RSA modulus		
    BgwPrivateParams bgw_private_params = 2; // the BGW private parameters associated with N    
    bool passes = 3; // the result of the Biprimality test. True if succeed, false if not
}

message KeysDerivationPrivateParams {
    uint32 i = 1; // the id of the party
    message Polynomial {
        repeated bytes a = 1;
    }
    Polynomial dri_sharing = 2;
    message PolynomialMod {
        repeated bytes a = 1;
        bytes mod = 2;
    }
    PolynomialMod betai_sharing = 3;
    PolynomialMod phi_sharing = 4;
    PolynomialMod zero_sharing = 5;
}

message KeysDerivationPublicParams {
    uint32 i = 1; // the id of the party
    uint32 j = 2; // the id of the party for which these shares were generated
    bytes betaij = 3;
    bytes drij = 4;
    bytes phiij = 5;
    bytes hij = 6;
}

/* TODO: "maybe this class should be encoded into genesis block" */
message ProtocolGenerationParams {
    bytes p = 1; // large prime P' used for secret sharing with polynomials over the integer mod P'
    uint32 n = 2; // the number of parties in the key generation protocol
    uint32 t = 3; // the maximum number of parties an adversary can corrupt without breaking the security of the protocol
    uint32 big_k = 4; // the security of the statistical hiding of &Phi;(N) with &Beta; and R
    uint32 k = 5; // the bitlength of p and q, so that N has a security of 2k
}
